# -*- coding: utf-8 -*-
"""ca√ßa_palavras.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NYi7d9OIjd71aDtmaYxkJO_f1tpS32AR
"""

from transformers import pipeline
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
import random


# === Step 1: Summarization ===
summarizer = pipeline("summarization", model="facebook/bart-large-cnn")

text = """
Quantum computing is an emerging field of technology that leverages the principles of quantum mechanics to perform computations far more efficiently than classical computers for certain problems. Unlike classical bits, which can only exist in a state of 0 or 1, quantum bits, or qubits, can exist in superpositions, allowing them to represent multiple states simultaneously. This property enables quantum computers to perform complex calculations at speeds that would be impossible with traditional computing architectures.

Another key feature of quantum computing is entanglement, a phenomenon where the state of one qubit is intrinsically linked to the state of another, regardless of distance. Entangled qubits can share information instantaneously, providing a powerful resource for parallelism and error correction in quantum algorithms. Quantum gates, the building blocks of quantum circuits, manipulate qubits through operations that exploit these quantum properties to solve computational problems efficiently.

Quantum computing has the potential to revolutionize many industries, including cryptography, optimization, drug discovery, and materials science. For example, Shor's algorithm can factor large numbers exponentially faster than classical methods, threatening traditional encryption schemes. Similarly, quantum simulations can model molecular interactions at a level of detail that classical computers cannot match, accelerating scientific discovery. Despite its promise, quantum computing is still in the experimental stage, with challenges such as qubit coherence, error rates, and hardware scalability limiting practical implementation. Researchers worldwide continue to explore new architectures, error correction techniques, and hybrid quantum-classical algorithms to unlock the full potential of this transformative technology.
"""

summary = summarizer(text, max_length=60, min_length=20, do_sample=False)[0]['summary_text']

print("\nOriginal text:\n", text)
print("\nSummary:\n", summary)

# === Step 2: Keyword Extraction ===

words = [word.strip(".,") for word in summary.split()]

num_words=int(input("Insert the number of words: "))


random_words=random.sample(words, num_words)
print("Random words: ", random_words)

# === Step 3: Generate Puzzle ===





# === Word search grid size ====
size = 12  # 12x12 grid

# === Step 1: Create empty grid ===
grid = [[" " for _ in range(size)] for _ in range(size)]

# === Step 2: Place words horizontally or vertically ===
for word in random_words:
    placed = False
    tries = 0
    while not placed and tries < 100:  # avoid infinite loop
        direction = random.choice([(1,0), (0,1)])  # horizontal or vertical
        x, y = random.randint(0, size-1), random.randint(0, size-1)

        if direction == (1,0) and x + len(word) <= size:  # horizontal
            for i in range(len(word)):
                grid[y][x+i] = word[i].upper()
            placed = True
        elif direction == (0,1) and y + len(word) <= size:  # vertical
            for i in range(len(word)):
                grid[y+i][x] = word[i].upper()
            placed = True
        tries += 1

# === Step 3: Fill empty spaces with random letters ===
for i in range(size):
    for j in range(size):
        if grid[i][j] == " ":
            grid[i][j] = chr(random.randint(65, 90))  # random uppercase letter

# === Step 4: Print the puzzle ===
print("\nWord Search Puzzle:\n")
for row in grid:
    print(" ".join(row))